{"title":"novo","steps":[{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":393,"codeSnippet":"        void attach() {\n            JComponent comp \u003d editor.getComponent();\n            JRootPane root \u003d SwingUtilities.getRootPane(comp);\n            if (root \u003d\u003d null) return;\n            JLayeredPane layered \u003d root.getLayeredPane();\n            if (getParent() !\u003d layered) layered.add(this, JLayeredPane.POPUP_LAYER);\n            comp.addComponentListener(compListener);\n            relayout();\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method is responsible for attaching a component to a layered pane within a Swing application. It retrieves the root pane of a given component, checks if it is null, and then adds the current instance to the layered pane at the popup layer if it is not already a child. Additionally, it registers a component listener and calls a relayout method to adjust the layout.\u003c/p\u003e","endLine":401,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#attach","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":403,"codeSnippet":"        void detach() {\n            Container p \u003d getParent();\n            if (p !\u003d null) p.remove(this);\n            editor.getComponent().removeComponentListener(compListener);\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThe detach method is responsible for removing the current object from its parent container and unregistering a component listener from an editor\u0027s component. It first retrieves the parent container and, if it exists, removes itself from that container. Additionally, it ensures that a specific component listener is removed from the editor\u0027s component to prevent memory leaks or unwanted behavior.\u003c/p\u003e","endLine":407,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#detach","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":409,"codeSnippet":"        private void relayout() {\n            JComponent comp \u003d editor.getComponent();\n            JRootPane root \u003d SwingUtilities.getRootPane(comp);\n            if (root \u003d\u003d null) return;\n            JLayeredPane layered \u003d root.getLayeredPane();\n\n            Point pt \u003d SwingUtilities.convertPoint(comp, 0, 0, layered);\n            setBounds(pt.x, pt.y, comp.getWidth(), comp.getHeight());\n\n            int btnW \u003d 140, btnH \u003d 30;\n            int gap \u003d 10;\n\n            int finishX \u003d getWidth() - btnW - 20;\n            int y \u003d getHeight() - btnH - 20;\n\n            finishBtn.setBounds(finishX, y, btnW, btnH);\n            clearBtn.setBounds(finishX - btnW - gap, y, btnW, btnH);\n\n            revalidate();\n            repaint();\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method adjusts the layout of a user interface component by determining its position within a layered pane and setting the bounds for two buttons. It calculates the appropriate positions based on the component\u0027s dimensions and ensures the layout is updated visually.\u003c/p\u003e","endLine":429,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#relayout","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":431,"codeSnippet":"        private void performFinalize() {\n            // Invoke FinalizeTourAction programmatically in the context of the editor\n            AnAction action \u003d ActionManager.getInstance().getAction(\"com.hackathon.actions.FinalizeTourAction\");\n            if (action !\u003d null) {\n                DataContext ctx \u003d SimpleDataContext.builder()\n                        .add(CommonDataKeys.PROJECT, project)\n                        .add(CommonDataKeys.EDITOR, editor)\n                        .build();\n                AnActionEvent ev \u003d AnActionEvent.createEvent(ctx, action.getTemplatePresentation(), \"AutoCodeWalker.SelectionHud\", ActionUiKind.NONE, null);\n                //noinspection deprecation\n                ActionUtil.performActionDumbAwareWithCallbacks(action, ev);\n            }\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method programmatically triggers the \u0027FinalizeTourAction\u0027 within an editor context. It retrieves the action using the ActionManager, constructs a data context with the current project and editor, creates an action event, and then executes the action while handling callbacks.\u003c/p\u003e","endLine":443,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#performFinalize","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":445,"codeSnippet":"        private void performClear() {\n            TourStateService state \u003d project.getService(TourStateService.class);\n            state.clear();\n            refreshAllEditors();\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method, performClear, retrieves the TourStateService from the project and invokes its clear method to reset the tour state. After clearing the state, it calls refreshAllEditors to update the user interface, ensuring that all editors reflect the cleared state.\u003c/p\u003e","endLine":449,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#performClear","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":365,"codeSnippet":"        FinishHud(Editor editor) {\n            this.editor \u003d editor;\n            setLayout(null);\n            setOpaque(false);\n\n            // Finish Button\n            finishBtn.setText(\"Finish Tour\");\n            finishBtn.setBackground(new JBColor(new Color(0, 120, 215), new Color(0, 90, 180)));\n            finishBtn.setForeground(Color.WHITE);\n            finishBtn.setOpaque(true);\n            finishBtn.setBorderPainted(false);\n            finishBtn.setFont(finishBtn.getFont().deriveFont(Font.BOLD));\n            finishBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n            finishBtn.addActionListener(e -\u003e performFinalize());\n            add(finishBtn);\n\n            // Clear Button\n            clearBtn.setText(\"Clear Selection\");\n            clearBtn.setBackground(new JBColor(new Color(220, 220, 220), new Color(80, 80, 80)));\n            clearBtn.setForeground(new JBColor(Color.BLACK, Color.WHITE));\n            clearBtn.setOpaque(true);\n            clearBtn.setBorderPainted(false);\n            clearBtn.setFont(finishBtn.getFont());\n            clearBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n            clearBtn.addActionListener(e -\u003e performClear());\n            add(clearBtn);\n        }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis code defines a constructor for the FinishHud class, which initializes the user interface for a tour completion dialog. It sets up two buttons: \u0027Finish Tour\u0027 and \u0027Clear Selection\u0027, configuring their appearance, behavior, and event handling. The buttons are styled with specific colors, fonts, and cursor types, and are added to the layout of the dialog.\u003c/p\u003e","endLine":391,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud#FinishHud","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":343,"codeSnippet":"    private void attachFinishHud(Editor editor) {\n        if (editor \u003d\u003d null || editor.getProject() \u003d\u003d null) return;\n        if (finishHuds.containsKey(editor)) return;\n        FinishHud hud \u003d new FinishHud(editor);\n        finishHuds.put(editor, hud);\n        hud.attach();\n    }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method checks if the provided editor is valid and not already associated with a Finish HUD. If valid, it creates a new Finish HUD instance, associates it with the editor, and attaches it for use.\u003c/p\u003e","endLine":349,"symbolName":"com.hackathon.service.SelectionModeService#attachFinishHud","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":351,"codeSnippet":"    private void detachFinishHud(Editor editor) {\n        FinishHud hud \u003d finishHuds.remove(editor);\n        if (hud !\u003d null) hud.detach();\n    }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThis method removes a FinishHud instance associated with a given Editor from a collection and calls its detach method if it exists, ensuring proper cleanup.\u003c/p\u003e","endLine":354,"symbolName":"com.hackathon.service.SelectionModeService#detachFinishHud","type":"method"},{"filePath":"C:/Users/lazar/IdeaProjects/JB-plugin/src/main/java/com/hackathon/service/SelectionModeService.java","lineNum":356,"codeSnippet":"    private final class FinishHud extends JComponent {\n        private final Editor editor;\n        private final JButton finishBtn \u003d new JButton(\"Finish Tour\");\n        private final JButton clearBtn \u003d new JButton(\"Clear Selection\");\n        private final java.awt.event.ComponentListener compListener \u003d new java.awt.event.ComponentAdapter() {\n            @Override public void componentResized(java.awt.event.ComponentEvent e) { relayout(); }\n            @Override public void componentMoved(java.awt.event.ComponentEvent e) { relayout(); }\n        };\n\n        FinishHud(Editor editor) {\n            this.editor \u003d editor;\n            setLayout(null);\n            setOpaque(false);\n\n            // Finish Button\n            finishBtn.setText(\"Finish Tour\");\n            finishBtn.setBackground(new JBColor(new Color(0, 120, 215), new Color(0, 90, 180)));\n            finishBtn.setForeground(Color.WHITE);\n            finishBtn.setOpaque(true);\n            finishBtn.setBorderPainted(false);\n            finishBtn.setFont(finishBtn.getFont().deriveFont(Font.BOLD));\n            finishBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n            finishBtn.addActionListener(e -\u003e performFinalize());\n            add(finishBtn);\n\n            // Clear Button\n            clearBtn.setText(\"Clear Selection\");\n            clearBtn.setBackground(new JBColor(new Color(220, 220, 220), new Color(80, 80, 80)));\n            clearBtn.setForeground(new JBColor(Color.BLACK, Color.WHITE));\n            clearBtn.setOpaque(true);\n            clearBtn.setBorderPainted(false);\n            clearBtn.setFont(finishBtn.getFont());\n            clearBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n            clearBtn.addActionListener(e -\u003e performClear());\n            add(clearBtn);\n        }\n\n        void attach() {\n            JComponent comp \u003d editor.getComponent();\n            JRootPane root \u003d SwingUtilities.getRootPane(comp);\n            if (root \u003d\u003d null) return;\n            JLayeredPane layered \u003d root.getLayeredPane();\n            if (getParent() !\u003d layered) layered.add(this, JLayeredPane.POPUP_LAYER);\n            comp.addComponentListener(compListener);\n            relayout();\n        }\n\n        void detach() {\n            Container p \u003d getParent();\n            if (p !\u003d null) p.remove(this);\n            editor.getComponent().removeComponentListener(compListener);\n        }\n\n        private void relayout() {\n            JComponent comp \u003d editor.getComponent();\n            JRootPane root \u003d SwingUtilities.getRootPane(comp);\n            if (root \u003d\u003d null) return;\n            JLayeredPane layered \u003d root.getLayeredPane();\n\n            Point pt \u003d SwingUtilities.convertPoint(comp, 0, 0, layered);\n            setBounds(pt.x, pt.y, comp.getWidth(), comp.getHeight());\n\n            int btnW \u003d 140, btnH \u003d 30;\n            int gap \u003d 10;\n\n            int finishX \u003d getWidth() - btnW - 20;\n            int y \u003d getHeight() - btnH - 20;\n\n            finishBtn.setBounds(finishX, y, btnW, btnH);\n            clearBtn.setBounds(finishX - btnW - gap, y, btnW, btnH);\n\n            revalidate();\n            repaint();\n        }\n\n        private void performFinalize() {\n            // Invoke FinalizeTourAction programmatically in the context of the editor\n            AnAction action \u003d ActionManager.getInstance().getAction(\"com.hackathon.actions.FinalizeTourAction\");\n            if (action !\u003d null) {\n                DataContext ctx \u003d SimpleDataContext.builder()\n                        .add(CommonDataKeys.PROJECT, project)\n                        .add(CommonDataKeys.EDITOR, editor)\n                        .build();\n                AnActionEvent ev \u003d AnActionEvent.createEvent(ctx, action.getTemplatePresentation(), \"AutoCodeWalker.SelectionHud\", ActionUiKind.NONE, null);\n                //noinspection deprecation\n                ActionUtil.performActionDumbAwareWithCallbacks(action, ev);\n            }\n        }\n\n        private void performClear() {\n            TourStateService state \u003d project.getService(TourStateService.class);\n            state.clear();\n            refreshAllEditors();\n        }\n    }","authorNote":"","aiExplanation":"\u003ch3\u003eSummary\u003c/h3\u003e\u003cp\u003eThe FinishHud class is a custom Swing component designed to provide a user interface for finishing a tour and clearing selections within an editor. It contains two buttons: \u0027Finish Tour\u0027 and \u0027Clear Selection\u0027, each with specific actions tied to them. The class manages its layout dynamically based on the editor\u0027s component size and position, ensuring that the buttons are always positioned correctly. It also handles attaching and detaching itself from the editor\u0027s component, and it invokes specific actions when the buttons are clicked.\u003c/p\u003e","endLine":450,"symbolName":"com.hackathon.service.SelectionModeService.FinishHud","type":"class"}]}